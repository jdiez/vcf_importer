#!/usr/bin/env python

import dxpy
import math
import operator
from optparse import OptionParser
import re
import sys

import subprocess
import time
import logging

sys.path.append('/usr/local/lib/')
import magic

logging.basicConfig(level=logging.DEBUG)



sys.path.append('/usr/local/lib/')
import magic


#Example: dx_vcfToSimplevar --table_id gtable-9yZvF200000PYKJyV4k00005 --vcf_file variants.vcf --extract_header

def main():

    parser = OptionParser("Usage: % mappings_id file_name")
    parser.add_option("--table_id", dest="simplevar_id", action="append", help="Simplevar table id to read from")
    parser.add_option("--vcf_file", dest="file_name", help="Name of file to import VCF from")
    parser.add_option("--infer_no_call", dest="infer_no_call", action = "store_true", default = False, help="All contigous blocks of no-call will be compressed to a single row")
    parser.add_option("--compress_reference", dest="compress_reference", action="store_true", default = False, help="All contiguous blocks of reference will be compressed to a single row")
    parser.add_option("--store_full_vcf", dest="store_full_vcf", action="store_true", default = False, help="All contiguous blocks of reference will be compressed to a single row")
    parser.add_option("--extract_header", dest="extract_header", action="store_true", default = False, help="Use this to set the details for the header data")
    parser.add_option("--store_samples_individually", dest="store_samples_individually", action="store_true", default = False, help="Each column of samples will be stored in its own gtable. You must provide as many table_ids as there are columns")
    parser.add_option("--region_file", dest="region_file", default="", help="Regions to process for variants in the format Chr:lo-hi")

    (opts, args) = parser.parse_args()
    
    simpleVarArray = []
    priors = []
    for x in opts.simplevar_id:
        simpleVarArray.append(dxpy.open_dxgtable(x))
        priors.append({'chr':'', 'position':-1})
    #vcfFile = open(opts.file_name, 'r')
    vcfFileName = opts.file_name
    print vcfFileName
    print open(vcfFileName, 'r').readline()
    inferNoCall = opts.infer_no_call
    compressReference = opts.compress_reference
    storeFullVcf = opts.store_full_vcf
    extractHeader = opts.extract_header

    priorType = "None"
    priorPosition = -1

    #fileIter = vcfFile.__iter__()
    count = 1

    #Additional data will contain the extra format and info columns that are optional in VCF and may not be
    #   present in the VCF file. These are stored in an extended table 
    additionalData = []

    refBuffer = {}
    for sample in range(len(simpleVarArray)):
        refBuffer[sample] = []
    

    try:
        originalContig = simpleVarArray[0].get_details()['original_contigset']
    except:
        raise Exception("The original reference genome must be attached as a detail")

    regions = {}
    contigDetails = dxpy.DXRecord(originalContig).get_details()['contigs']
    contigNames = contigDetails['names']
    contigSizes = contigDetails['sizes']
    
    if opts.region_file != "":
        regionText = open(opts.region_file, 'r').read()
        intervalMatch = re.findall("(\w+):(\d+)-(\d+)", regionText)
        for x in intervalMatch:
            if regions.get(x[0]) == None:
                regions[x[0]] = []
            min = int(x[1])
            max = int(x[2])
            if max >= contigSizes[contigNames.index(x[0])]:
                max = contigSizes[contigNames.index(x[0])]-1
            regions[x[0]].append([min, max])
    else:
        for i in range(len(contigNames)):
            regions[contigNames[i]] = [[0, contigSizes[i]-1]]
    
    
    
    highestObservedInRegion = {}
    for sample in range(len(simpleVarArray)):
        highestObservedInRegion[sample] = {}
        for x in regions:
            highestObservedInRegion[sample][x] = []
            for y in regions[x]:
                highestObservedInRegion[sample][x].append(y[0])
                
    lastRegion = []
    for sample in range(len(simpleVarArray)):
        lastRegion.append(['', -1])
    
    header = ''
    with unpack_and_open(vcfFileName) as vcfFile:
        while 1:
            try:
                input = vcfFile.next()
                if count%100000 == 0:
                    print "Processed count %i variants " % count
                count += 1
                if input[0] == "#":
                    header += input
                    #extract additional column header data
                    if(input[1] != "#"):
                        if extractHeader:
                            applyHeaderInfomation(simpleVarArray, header)
                else:
                    for sample in range(len(simpleVarArray)):
                        simpleVar = simpleVarArray[sample]
                        vcfLine = parseVcfLine(opts.store_samples_individually, input, sample)
                        regionIndex = checkWithinRegion(vcfLine['chr'], vcfLine['lo'], vcfLine['hi'], regions)
                        if regionIndex > -1:
                            
                            if lastRegion[sample][0] != vcfLine['chr'] or lastRegion[sample][1] != regionIndex:
                                lastRegion[sample][0] = vcfLine['chr']
                                lastRegion[sample][1] = regionIndex
                                priors[sample]['position'] = regions[vcfLine['chr']][regionIndex][0]
                                priors[sample]['chr'] = vcfLine['chr']
                            if vcfLine['hi'] > highestObservedInRegion[sample][vcfLine['chr']][regionIndex]:
                                highestObservedInRegion[sample][vcfLine['chr']][regionIndex] = vcfLine['hi']
                            if vcfLine['altOptions'] == [vcfLine['ref'], '.'] or vcfLine == [vcfLine['ref']]:
                                writeReferenceRow(simpleVar, vcfLine, priors, sample, compressReference, storeFullVcf, refBuffer)
                            else:
                                #Write variant row
                                if writeVariantRow(simpleVar, vcfLine, storeFullVcf) == "ref":
                                    writeReferenceRow(simpleVar, vcfLine, priors, sample, compressReference, storeFullVcf, refBuffer)
                                else:
                                    writeReferenceBuffer(simpleVar, refBuffer, sample, storeFullVcf)
        
                            #If there are intervening blank lines, write those as no-call
                            if vcfLine['lo'] - priors[sample]['position'] > 0:
                                priors[sample]['position']
                                if inferNoCall:
                                    writeNoCallRow(simpleVar, priors[sample]['chr'], priors[sample]['position'], vcfLine['lo'], storeFullVcf)
                            priors[sample]['position'] = vcfLine['hi']
                        else:
                            writeReferenceBuffer(simpleVar, refBuffer, sample, storeFullVcf)
    
            except StopIteration:
                break
        for sample in range(len(simpleVarArray)):
            writeReferenceBuffer(simpleVarArray[sample], refBuffer, sample, storeFullVcf)
    
        if inferNoCall:
            for sample in range(len(simpleVarArray)):
                simpleVar = simpleVarArray[sample]
                for chr, reg in highestObservedInRegion[sample].iteritems():
                    for i in range(len(reg)):
                        if reg[i] < regions[chr][i][1]:
                            writeNoCallRow(simpleVarArray[sample], chr, reg[i], regions[chr][i][1], storeFullVcf)
    

    
def checkWithinRegion(chr, lo, hi, regions):
    for x in regions[chr]:
        if (lo >= x[0] and lo <= x[1]) or (hi >= x[0] and hi <= x[1]):
            return regions[chr].index(x)
    return -1
        
def writeReferenceRow(simpleVar, vcfLine, priors, sample, compressReference, storeFullVcf, refBuffer):
    #Always write the reference row if we are not compressing
    if compressReference == False:
        writeReferenceRowData(simpleVar, vcfLine, storeFullVcf, False, refBuffer, sample)
    else:
        writeReferenceRowData(simpleVar, vcfLine, storeFullVcf, True, refBuffer, sample)
                
def writeVariantRow(simpleVar, line, storeFullVcf):
    
    chr = line['chr']
    lo = line['lo']
    hi = line['hi']
    ref = line['ref']
    altOptions = line['altOptions']
    qual = line['qual']
    formatColumn = line['formatColumn']
    infoColumn = line['infoColumn']
    totalCoverage = line['totalCoverage']
    tabSplit = line['tabSplit']
    
    altCoverage = []
    for x in altOptions:
        altCoverage.append(0)
    
    #recordCoverage = False
    #if "coverage" in simpleVar.get_col_names():
    #    recordCoverage = True
        
    #In VCF format, the prior character to a sequence change is given in some cases (Ins, Del)
    #   we are removing this in our format, and so need to figure out which characters to filter   
    overlap = checkOverlap(ref, altOptions)
    ref = ref[overlap:]
    for i in range(len(altOptions)):
        altOptions[i] = altOptions[i][overlap:]
    
    #Find all of the genotypes 
    genotypePossibilities = {}
    allNoCall = True
    allRef = True
    totalCoverage = 0
    for x in tabSplit[9:]:
        mappedReads = getInfoField("DP", infoColumn, x)
        if mappedReads != False:
            totalCoverage += int(mappedReads)
        covByAlt = getInfoField("AD", infoColumn, x)
        if covByAlt != False:
            covByAltSplit = covByAlt.split(",")
            for i in range(len(covByAltSplit)):
                altCoverage[i] += int(covByAltSplit[i])
        genotype = getInfoField("GT", infoColumn, x)
        if genotype != "./.":
            allNoCall = False
            if genotype != "0|0" and genotype != "0/0":
                allRef = False
            genotypeQuality = float(getInfoField("GQ", infoColumn, x))
            if genotypeQuality == False:
                genotypeQuality = 0
            if genotype != False:
                if genotypePossibilities.get(genotype) == None:
                    genotypePossibilities[genotype] = float(genotypeQuality)
                else:
                    genotypePossibilities[genotype] += float(genotypeQuality)
            
            else:
                genotypeQuality = 0
    if allNoCall == False and allRef == False:
        genotypePossibilities = sorted(genotypePossibilities.iteritems(), key=operator.itemgetter(1), reverse=True)
        if len(genotypePossibilities) > 0:
            genotype = genotypePossibilities[0][0]
            genotypeQuality = genotypePossibilities[0][1]
            if len(genotypePossibilities) > 1:
                genotypeQuality -= genotypePossibilities[1][1]
            alt = ""
            if genotype == "0/0" or genotype == "0|0" or genotype == False:
                if(len(genotypePossibilities) > 1):
                    genotype = genotypePossibilities[1][0]
                    genotypeQuality = 0
                else:
                    type = "ref"
                    
                    
            genotypeSplit = re.split("[\|\/]", genotype)
            for i in range(len(genotypeSplit)):
                
            #This is done to ensure the convention of placing the ref allele first
            #   in practice, it seems that all VCFs already place the ref first
                genotypeSplit[i] = int(genotypeSplit[i])
            genotypeSplit.sort()

            coverage = ''
            alleles = []
            for x in genotypeSplit:
                if len(alt) > 0:
                    alt += "/"
                    coverage += "/"
                alt += altOptions[x]
                coverage += str(altCoverage[x])
                if x != 0:
                    alleles.append(altOptions[x])
                if len(altOptions[x]) == 0:
                    alt += "-"
        else:
            alt = "?"
            for x in altOptions:
                alt += "/"+x
            genotypeQuality = 0
            
        typeList = []                
        #These rules determine how to characterize the type of change that has occurred
        for x in alleles:
            if len(x) == len(ref) and len(ref) == 1:
                type = "snp"
            elif len(x) == len(ref):
                type = "mnp"
            elif len(x) > len(ref) and isSubSequence(x, ref):
                type = "ins"
            elif len(x) < len(ref) and isSubSequence(ref, x):
                type = "del"
            else:
                type = "complex"
            typeList.append(type)
            typeList = list(set(typeList))
            if len(typeList) > 1:
                type = "mixed"
                break                                
            

        if len(ref) == 0:
            ref = "-"
        entry = [chr, lo, hi, type, ref.upper(), alt.upper(), qual, coverage, totalCoverage, int(genotypeQuality)]
        if storeFullVcf:
            entry.append(tabSplit[4])
            vcfSpecificData = ''
            for x in tabSplit[7:]:
                vcfSpecificData += x+"\t"
            entry.append(vcfSpecificData.strip())
        simpleVar.add_rows([entry])
    elif allNoCall:
        writeNoCallRow(simpleVar, chr, lo, hi, storeFullVcf)
    else:
        return "ref"
    return "No action needed"

def parseVcfLine(storeSamplesIndividually, input, sample):
    if storeSamplesIndividually:
        line = ''
        tabSplit = input.strip().split("\t")
        for x in tabSplit[:9]:
            line += x+"\t"
        line += tabSplit[9+sample]
    else:
        line = input
    tabSplit = line.strip().split("\t")
    chr = tabSplit[0]
    lo = int(tabSplit[1])-1
    ref = tabSplit[3].replace(".","")
    hi = lo + len(ref)

    #In VCF format, the ALT column holds possible candidate alleles. The actual call as to the
    #   variant and its zygosity is a combination of ALT and the genotype specified in the info field.
    #   We store all of the options (including ref) and calculated the actual calls later
    altOptions = [ref]
    altOptions.extend(tabSplit[4].split(","))
    qual = tabSplit[5]
    type = "unknown"
    overlap = checkOverlap(ref, altOptions)
    lo += overlap
    if qual == ".":
        type = "no-call"
        qual = 0
    else:
        qual = int(float(tabSplit[5]))

    formatColumn = tabSplit[7]
    infoColumn = ''
    if len(tabSplit) > 8:
        infoColumn = tabSplit[8]
    genotypeQuality = 0
    
    if storeSamplesIndividually:
        totalCoverage = re.findall("DP=(\d+);", formatColumn)
        if(len(totalCoverage) > 0):
            totalCoverage = int(totalCoverage[0])
        else:
            totalCoverage = 0
    else:
        totalCoverage = 0
        
    return {'chr':chr, 'lo':lo, 'hi':hi, 'ref':ref, 'tabSplit':tabSplit, 'altOptions':altOptions, 'qual':qual, 'formatColumn':formatColumn, 'infoColumn':infoColumn, 'genotypeQuality':genotypeQuality, 'totalCoverage':totalCoverage}



def checkOverlap(ref, altOptions):
    overlap = 1
    for x in altOptions:
        if len(x) > 0 and len(ref) > 0:
            if x[0] != ref[0]:
                return 0
    return 1

def isSubSequence(longer, shorter):
    if len(shorter) == 0:
        return True
    s = 0;
    l = 0;
    while l != len(longer):
        if longer[l] == shorter[s]:
            s += 1
            if s == len(shorter):
                return True
        l += 1
    return False

def getInfoField(fieldName, infoColumn, infoContents):
    if infoColumn.count(fieldName) > 0:
        entrySplitColumn = infoColumn.split(":")
        position = -1
        for i in range(len(entrySplitColumn)):
            if entrySplitColumn[i] == fieldName:
                position = i
                entrySplitInfo = infoContents.split(":")
                if len(entrySplitInfo) > position:
                    return entrySplitInfo[position]
    return False
    
    
def applyHeaderInfomation(simpleVarArray, header):
    for simpleVar in simpleVarArray:
      details = simpleVar.get_details()
      if details.get('header') == None:
          details.update({'header':header})
          simpleVar.set_details(details)

def generateEmptyList(columns):
    result = []
    for i in range(columns):
        result.append('')
    return result

def findCoveragePerAllele(line):
    result = ''
    fraction = re.findall("AF=(.*?);", line)    
    coverage = int(re.findall("DP=(\d+)", text)[0])
    for x in fraction.split(","):
        if len(result) > 0:
            result += "/"
        result += str(int(float(coverage)*float(fraction)))
    return result

def writeReferenceRowData(simpleVar, vcfLine, storeFullVcf, storeInBuffer, refBuffer, sample):

    chr = vcfLine['chr']
    lo = vcfLine['lo']
    hi = vcfLine['hi']
    ref = vcfLine['ref']
    altOptions = vcfLine['altOptions']
    qual = vcfLine['qual']
    formatColumn = vcfLine['formatColumn']
    infoColumn = vcfLine['infoColumn']
    tabSplit = vcfLine['tabSplit']
    
    totalCoverage = 0
    coverage = ''
    for x in tabSplit[9:]:
        covByAlt = getInfoField("AD", infoColumn, x)
        if covByAlt != False:
            print covByAlt
            covByAltSplit = covByAlt.split(",")
            coverage = str(covByAltSplit[0])
            for i in range(len(covByAltSplit)):
                totalCoverage += int(covByAltSplit[i])
        else:
            mappedReads = getInfoField("DP", infoColumn, x)
            if mappedReads != False:
                totalCoverage += int(mappedReads)

    entry = [chr, lo, hi, "ref", ref.upper(), ref.upper(), qual, coverage, totalCoverage, qual]
    if storeFullVcf:
        entry.append(tabSplit[4])
        vcfSpecificData = ''
        for x in tabSplit[7:]:
            vcfSpecificData += x+"\t"
        entry.append(vcfSpecificData.strip())
    if storeInBuffer:
        refBuffer[sample].append(entry[:])
    else:
        simpleVar.add_rows([entry][:])

def writeCompressedReferenceRow(simpleVar, chr, lo, hi, storeFullVcf):
    entry = [chr, lo, hi, "ref", "", "", 0, "", 0, 0]
    if storeFullVcf:
        entry.extend([".", ""])
    simpleVar.add_rows([entry])

def writeNoCallRow(simpleVar, chr, lo, hi, storeFullVcf):
    entry = [chr, lo, hi, "no-call", "", "", 0, "", 0, 0]
    if storeFullVcf:
        entry.extend([".", ""])
    simpleVar.add_rows([entry][:])
        
def writeReferenceBuffer(simpleVar, refBuffer, sample, storeFullVcf):
    row = []
    for x in refBuffer[sample][:]:
        if row == []:
            row = [x[0], x[1], x[2], "ref", "", "", 0, "", 0, 0]
        elif row[2] == x[1]:
            row[2] = x[2]
        else:
            if storeFullVcf:
                row.extend([".",""])
            simpleVar.add_rows([row])
            row = [x[0], x[1], x[2], "ref", "", "", 0, "", 0, 0]
    if row != []:
        if storeFullVcf:
            row.extend([".",""])
        simpleVar.add_rows([row][:])
    refBuffer[sample][:] = []

def checkRowValidity(row, storeFullVcf):
    if storeFullVcf:
        if len(row) != 9:
            print False
            print row
    else:
        if len(row) != 7:
            print False
            print row
            
    if type(row[0]) is not str:
        print 0
    if type(row[1]) is not int:
        print 1
    if type(row[2]) is not int:
        print 2
    if type(row[3]) is not str:
        print 3
    if type(row[4]) is not str:
        print 4
    if type(row[5]) is not str:
        print 5
    if type(row[6]) is not int:
        print 6
    if type(row[7]) is not int:
        print 7
    if type(row[8]) is not int:
        print 8
    if storeFullVcf:
        if type(row[9]) is not str:
            print 9
        if type(row[10]) is not str:
            print 10
            
    
    if type(row[0]) is str:
        if type(row[1]) is int:
            if type(row[2]) is int:
                if type(row[3]) is str:
                    if type(row[4]) is str:
                        if type(row[5]) is str:
                            if type(row[6]) is int:
                                if type(row[7]) is int:
                                    if type(row[8]) is int:
                                        if storeFullVcf:
                                            if type(row[9]) is str:
                                                if type(row[10]) is str:
                                                    return True
                                        else:
                                            return True
    print False
    print row
    return False


def unpack_and_open(input):
    m = magic.Magic()

    # determine compression format
    try:
        file_type = m.from_file(input)
    except:
        raise dxpy.ProgramError("Unable to identify compression format")

    print file_type

    # if uncompressed open the file and return a handle to it
    try:
        if file_type == 'ASCII text' or file_type == 'ASCII English text, with very long lines':
            return open(input)
    except:
        raise dxpy.ProgramError("Detected uncompressed input but unable to open file. File may be corrupted.")

    # if we find a tar file throw a program error telling the user to unpack it
    if file_type == 'application/x-tar':
        raise dxpy.ProgramError("Program does not support tar files.  Please unpack.")

    # since we haven't returned, the file is compressed.  Determine what program to use to uncompress
    uncomp_util = None
    if file_type == 'XZ compressed data':
        uncomp_util = 'xzcat'
    elif file_type[:21] == 'bzip2 compressed data':
        uncomp_util = 'bzcat'
    elif file_type[:20] == 'gzip compressed data':
        uncomp_util = 'zcat'
    elif file_type == 'POSIX tar archive (GNU)' or 'tar' in file_type:
        raise dxpy.ProgramError("Found a tar archive.  Please untar your sequences before importing")
    else:
        raise dxpy.ProgramError("Unsupported compression type.  Supported formats are xz, gzip, bzip, and uncompressed")

    # with that in hand, open file for reading.  If we find a tar archive then exit with error.
    try:
        with subprocess.Popen([uncomp_util, input], stdout=subprocess.PIPE).stdout as pipe:
            line = pipe.next()
        uncomp_type = m.from_buffer(line)
        print uncomp_type
    except:
        raise dxpy.ProgramError("Error detecting file format after decompression")

    if uncomp_type == 'POSIX tar archive (GNU)' or 'tar' in uncomp_type:
        raise dxpy.ProgramError("Found a tar archive after decompression.  Please untar your sequences before importing")
    elif uncomp_type != 'ASCII text':
        raise dxpy.ProgramError("After decompression found file type other than plain text")
    
    try:
        return subprocess.Popen([uncomp_util, input], stdout=subprocess.PIPE).stdout
    except:
        raise dxpy.ProgramError("Unable to open compressed input for reading")


main()
