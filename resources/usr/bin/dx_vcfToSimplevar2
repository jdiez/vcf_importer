#!/usr/bin/env python

import dxpy
import math
import operator
from optparse import OptionParser
import re

#Example: dx_vcfToSimplevar --table_id gtable-9yZvF200000PYKJyV4k00005 --vcf_file variants.vcf --extract_header

def main():

    parser = OptionParser("Usage: % mappings_id file_name")
    parser.add_option("--table_id", dest="simplevar_id", action="append", help="Simplevar table id to read from")
    parser.add_option("--vcf_file", dest="file_name", help="Name of file to import VCF from")
    parser.add_option("--compress_no_call", dest="compress_no_call", action = "store_true", default = False, help="All contigous blocks of no-call will be compressed to a single row")
    parser.add_option("--compress_reference", dest="compress_reference", action="store_true", default = False, help="All contiguous blocks of reference will be compressed to a single row")
    parser.add_option("--store_full_vcf", dest="store_full_vcf", action="store_true", default = False, help="All contiguous blocks of reference will be compressed to a single row")
    parser.add_option("--extract_header", dest="extract_header", action="store_true", default = False, help="Use this to set the details for the header data")
    parser.add_option("--store_samples_individually", dest="store_samples_individually", action="store_true", default = False, help="Each column of samples will be stored in its own gtable. You must provide as many table_ids as there are columns")

    (opts, args) = parser.parse_args()
    
    print opts.store_samples_individually
    
    simpleVarArray = []
    priors = []
    for x in opts.simplevar_id:
        simpleVarArray.append(dxpy.open_dxgtable(x))
        priors.append({'chr':'', 'refLo':-1, 'position':-1})
    vcfFile = open(opts.file_name, 'r')
    compressNoCall = opts.compress_no_call
    compressReference = opts.compress_reference
    storeFullVcf = opts.store_full_vcf
    extractHeader = opts.extract_header

    try:
        originalContig = simpleVarArray[0].get_details()['original_contigset']
    except:
        raise Exception("The original reference genome must be attached as a detail")

    contigDetails = dxpy.DXRecord(originalContig).get_details()['contigs']
    contigNames = contigDetails['names']
    contigSizes = contigDetails['sizes']

    print contigNames
    print contigSizes
    
    priorType = "None"
    priorPosition = -1

    fileIter = vcfFile.__iter__()
    count = 1

    #Additional data will contain the extra format and info columns that are optional in VCF and may not be
    #   present in the VCF file. These are stored in an extended table 
    additionalData = []
    
    header = ''
    while 1:
        try:
            input = fileIter.next()
            if count%100000 == 0:
                print "Processed count %i variants " % count
            count += 1
            if input[0] == "#":
                header += input
                #extract additional column header data
                if(input[1] != "#"):
                    if extractHeader:
                        applyHeaderInfomation(simpleVarArray, header)
            else:
                for sample in range(len(simpleVarArray)):
                    #print "Priors: " + str(priors[sample]['chr'])
                    #print "Priors: " + str(priors[sample]['refLo'])
                    #print "Priors: " + str(priors[sample]['position'])

                    simpleVar = simpleVarArray[sample]
                    vcfLine = parseVcfLine(opts.store_samples_individually, input, sample)

                    if priors[sample]['chr'] != vcfLine['chr']:
                        #Write all buffered reference lines before leaving chromosome
                        if compressReference and priors[sample]['refLo'] != -1:
                            writeCompressedReferenceRow(simpleVar, priors[sample]['chr'], priors[sample]['refLo'], priors['sample']['position'])

                        #Write no-calls from current position to the end of the last chromosome
                        if priors[sample]['position'] > -1:
                            chrLength = contigSizes[contigNames.index(priors[sample]['chr'])]-1
                            if priors[sample]['position'] < chrLength:
                                writeNoCallRow(simpleVar, priors[sample]['chr'], priors[sample]['position'], chrLength, storeFullVcf)
                        priors[sample]['chr'] = vcfLine['chr']
                        priors[sample]['position'] = 0
                        priors[sample]['refLo'] = -1


                    if vcfLine['altOptions'] == [vcfLine['ref'], '.'] or vcfLine == [vcfLine['ref']]:
                        #Write reference row
                        if compressReference == False:
                            writeReferenceRow(vcfLine, storeFullVcf)

                        #If there are no reference lines in the buffer, start the buffer
                        elif priors[sample]['refLo'] == -1:
                            priors[sample]['refLo'] = vcfLine['lo']

                        #If there are reference lines in the buffer, write them
                        elif priors[sample][position] != vcfLine['lo']:
                            writeCompressedReferenceRow(simpleVar, priors[sample]['chr'], priors[sample]['refLo'], priors['sample']['position'])
                            priors[sample]['refLo'] = -1
                    else:
                        #Write variant row
                        writeVariantRow(simpleVar, vcfLine, storeFullVcf)
                        
                        #Write the previous reference buffer, if needed and it exists
                        if compressReference and priors[sample]['refLo'] != -1:
                            writeCompressedReferenceRow(simpleVar, priors[sample]['chr'], priors[sample]['refLo'], priors['sample']['position'])
                            priors[sample]['refLo'] = -1

                    #If there are intervening blank lines, write those as no-call
                    print "Prior position"+str(priors[sample]['position'])
                    print "VcfLine"+str(vcfLine['lo'])
                    if vcfLine['lo'] - priors[sample]['position'] > 1:
                        priors[sample]['position']
                        writeNoCallRow(simpleVar, priors[sample]['chr'], priors[sample]['position'], vcfLine['lo'], storeFullVcf)
                    

                    priors[sample]['position'] = vcfLine['hi']
                        
                    #if compressReference:
                    #    if priorType == "Ref" and type != priorType:
                    #        entry = [chr, priorPosition, lo, type, "", "", 0, 0, 0]
                    #        if storeFullVcf:
                    #            entry.extend([".", ""])
                    #        simpleVar.add_rows([entry])                        
                    #if compressNoCall:
                    #    if priorType == "No-call" and type != priorType:
                    #        entry = [chr, priorPosition, lo, type, "", "", 0, 0, 0]
                    #        if storeFullVcf:
                    #            entry.extend([".",""])
                    #        simpleVar.add_rows([entry])
                    #if type != priorType:
                    #    priorType = type
                    #    priorPosition = lo-1
        except StopIteration:
            break
        
        
        
def writeVariantRow(simpleVar, line, storeFullVcf):
    
    chr = line['chr']
    lo = line['lo']
    hi = line['hi']
    ref = line['ref']
    altOptions = line['altOptions']
    qual = line['qual']
    formatColumn = line['formatColumn']
    infoColumn = line['infoColumn']
    coverage = line['coverage']
    tabSplit = line['tabSplit']
    
    #In VCF format, the prior character to a sequence change is given in some cases (Ins, Del)
    #   we are removing this in our format, and so need to figure out which characters to filter   
    overlap = checkOverlap(ref, altOptions)
    ref = ref[overlap:]
    for i in range(len(altOptions)):
        altOptions[i] = altOptions[i][overlap:]
    
    #Find all of the genotypes 
    genotypePossibilities = {}
    allNoCall = True
    allRef = True
    for x in tabSplit[9:]:
        genotype = getInfoField("GT", infoColumn, x)
        if genotype != "./.":
            allNoCall = False
            if genotype != "0|0" and genotype != "0/0":
                allRef = False
            genotypeQuality = float(getInfoField("GQ", infoColumn, x))
            if genotypeQuality == False:
                genotypeQuality = 0
            if genotype != False:
                if genotypePossibilities.get(genotype) == None:
                    genotypePossibilities[genotype] = float(genotypeQuality)
                else:
                    genotypePossibilities[genotype] += float(genotypeQuality)
            
            else:
                genotypeQuality = 0
    if allNoCall == False and allRef == False:
        genotypePossibilities = sorted(genotypePossibilities.iteritems(), key=operator.itemgetter(1), reverse=True)
        if len(genotypePossibilities) > 0:
            genotype = genotypePossibilities[0][0]
            genotypeQuality = genotypePossibilities[0][1]
            if len(genotypePossibilities) > 1:
                genotypeQuality -= genotypePossibilities[1][1]
            alt = ""
            if genotype == "0/0" or genotype == "0|0" or genotype == False:
                if(len(genotypePossibilities) > 1):
                    genotype = genotypePossibilities[1][0]
                    genotypeQuality = 0
                else:
                    type = "Ref"
                    
                    
            genotypeSplit = re.split("[\|\/]", genotype)
            for i in range(len(genotypeSplit)):
                
            #This is done to ensure the convention of placing the ref allele first
            #   in practice, it seems that all VCFs already place the ref first
                genotypeSplit[i] = int(genotypeSplit[i])
            genotypeSplit.sort()

            
            alleles = []
            for x in genotypeSplit:
                if len(alt) > 0:
                    alt += "/"
                alt += altOptions[x]
                if x != 0:
                    alleles.append(altOptions[x])
                if len(altOptions[x]) == 0:
                    alt += "-"
        else:
            alt = "?"
            for x in altOptions:
                alt += "/"+x
            genotypeQuality = 0
            
        typeList = []                
        #These rules determine how to characterize the type of change that has occurred
        for x in alleles:
            if len(x) == len(ref) and len(ref) == 1:
                type = "SNP"
            elif len(x) == len(ref):
                type = "MNP"
            elif len(x) > len(ref) and isSubSequence(x, ref):
                type = "Ins"
            elif len(x) < len(ref) and isSubSequence(ref, x):
                type = "Del"
            else:
                type = "Complex"
            typeList.append(type)
            typeList = list(set(typeList))
            if len(typeList) > 1:
                break                                
            

        if len(ref) == 0:
            ref = "-"
        entry = [chr, lo, hi, type, ref.upper(), alt.upper(), qual, coverage, int(genotypeQuality)]
        if storeFullVcf:
            entry.append(tabSplit[4])
            vcfSpecificData = ''
            for x in tabSplit[7:]:
                vcfSpecificData += x+"\t"
            entry.append(vcfSpecificData.strip())
        simpleVar.add_rows([entry])
    elif compressReference == False and allNoCall == False:
        type = "Ref"
        entry = [chr, lo, hi, type, "", "", 0, 0, 0]
        entry.append(tabSplit[4])
        vcfSpecificData = ''
        for x in tabSplit[7:]:
            vcfSpecificData += x+"\t"
        entry.append(tabSplit[7:].strip())
        simpleVar.add_rows([entry])
    else:
        type = "Ref"

def parseVcfLine(storeSamplesIndividually, input, sample):
    if storeSamplesIndividually:
        line = ''
        tabSplit = input.strip().split("\t")
        for x in tabSplit[:9]:
            line += x+"\t"
        line += tabSplit[9+sample]
    else:
        line = input
    tabSplit = line.strip().split("\t")
    chr = tabSplit[0]
    lo = int(tabSplit[1])-1
    ref = tabSplit[3].replace(".","")
    hi = lo + len(ref)
    print "Printing ref"
    for i in ref:
        print i
    print "Done"

        
    #In VCF format, the ALT column holds possible candidate alleles. The actual call as to the
    #   variant and its zygosity is a combination of ALT and the genotype specified in the info field.
    #   We store all of the options (including ref) and calculated the actual calls later
    altOptions = [ref]
    altOptions.extend(tabSplit[4].split(","))
    qual = tabSplit[5]
    type = "Unknown"
    overlap = checkOverlap(ref, altOptions)
    lo -= overlap
    hi -= overlap
    if qual == ".":
        type = "No-call"
        qual = 0
    else:
        qual = int(float(tabSplit[5]))

    formatColumn = tabSplit[7]
    infoColumn = tabSplit[8]
    genotypeQuality = 0
    
    coverage = re.findall("DP=(\d+);", formatColumn)
    if(len(coverage) > 0):
        coverage = int(coverage[0])
    else:
        coverage = 0
        
    return {'chr':chr, 'lo':lo, 'hi':hi, 'ref':ref, 'tabSplit':tabSplit, 'altOptions':altOptions, 'qual':qual, 'formatColumn':formatColumn, 'infoColumn':infoColumn, 'genotypeQuality':genotypeQuality, 'coverage':coverage}



def checkOverlap(ref, altOptions):
    overlap = 1
    print "Check alt options"
    print ref
    print altOptions
    for x in altOptions:
        if len(x) > 0 and len(ref) > 0:
            if x[0] != ref[0]:
                return 0
    return 1


def isSubSequence(longer, shorter):
    if len(shorter) == 0:
        return True
    s = 0;
    l = 0;
    while l != len(longer):
        if longer[l] == shorter[s]:
            s += 1
            if s == len(shorter):
                return True
        l += 1
    return False

def getInfoField(fieldName, infoColumn, infoContents):
    if infoColumn.count(fieldName) > 0:
        entrySplitColumn = infoColumn.split(":")
        position = -1
        for i in range(len(entrySplitColumn)):
            if entrySplitColumn[i] == fieldName:
                position = i
                entrySplitInfo = infoContents.split(":")
                if len(entrySplitInfo) == len(entrySplitColumn):
                    return entrySplitInfo[position]
    return False
    
    
def applyHeaderInfomation(simpleVarArray, header):
    for simpleVar in simpleVarArray:
      details = simpleVar.get_details()
      if details.get('header') == None:
          details.update({'header':header})
          simpleVar.set_details(details)

def generateEmptyList(columns):
    result = []
    for i in range(columns):
        result.append('')
    return result

def writeReferenceRow(simpleVar, vcfLine, storeFullVcf):
    print "writeReference"
    chr = line['chr']
    lo = line['lo']
    hi = line['hi']
    ref = line['ref']
    altOptions = line['altOptions']
    qual = line['qual']
    formatColumn = line['formatColumn']
    infoColumn = line['infoColumn']
    coverage = line['coverage']
    tabSplit = line['tabSplit']
    entry = [chr, lo-overlap-1, hi, type, ref.upper(), ref.upper(), qual, coverage, qual]
    if storeFullVcf:
        entry.append(tabSplit[4])
        vcfSpecificData = ''
        for x in tabSplit[7:]:
            vcfSpecificData += x+"\t"
        entry.append(vcfSpecificData.strip())
    simpleVar.add_rows([entry])

def writeCompressedReferenceRow(simpleVar, chr, lo, hi, storeFullVcf):
    print "writeCompressReference"
    entry = [chr, lo, hi, "Ref", "", "", 0, 0, 0]
    if storeFullVcf:
        entry.extend([".", ""])
    simpleVar.add_rows([entry])

def writeNoCallRow(simpleVar, chr, lo, hi, storeFullVcf):
    print "writeNoCall"
    print chr
    print lo
    print hi
    entry = [chr, lo, hi, "No-call", "", "", 0, 0, 0]
    if storeFullVcf:
        entry.extend([".", ""])
    simpleVar.add_rows([entry])


def checkRowValidity(row, storeFullVcf):
    if storeFullVcf:
        if len(row) != 9:
            print False
            print row
    else:
        if len(row) != 7:
            print False
            print row
            
    if type(row[0]) is not str:
        print 0
    if type(row[1]) is not int:
        print 1
    if type(row[2]) is not int:
        print 2
    if type(row[3]) is not str:
        print 3
    if type(row[4]) is not str:
        print 4
    if type(row[5]) is not str:
        print 5
    if type(row[6]) is not int:
        print 6
    if type(row[7]) is not int:
        print 7
    if type(row[8]) is not int:
        print 8
    if storeFullVcf:
        if type(row[9]) is not str:
            print 9
        if type(row[10]) is not str:
            print 10
            
    
    if type(row[0]) is str:
        if type(row[1]) is int:
            if type(row[2]) is int:
                if type(row[3]) is str:
                    if type(row[4]) is str:
                        if type(row[5]) is str:
                            if type(row[6]) is int:
                                if type(row[7]) is int:
                                    if type(row[8]) is int:
                                        if storeFullVcf:
                                            if type(row[9]) is str:
                                                if type(row[10]) is str:
                                                    return True
                                        else:
                                            return True
    print False
    print row
    return False


main()
